# üèóÔ∏è WINDSURF ARCHITECTURE - REGRAS DE ARQUITETURA

> Regras de arquitetura MVVM + Hilt + Multi-tenancy para WindSurf  
> Stack: Kotlin + Android + Room + Firebase + Coroutines + StateFlow  
> Baseado em PROJECT_README.md e DEV_GUIDE.md

---

## üéØ OBJETIVO

Configurar WindSurf com **regras de arquitetura r√≠gidas** para:
- **MVVM consistente** em todos componentes
- **Hilt para DI** (@Inject, @HiltViewModel)
- **Multi-tenancy por rota** obrigat√≥rio
- **Offline-first** com Room como fonte da verdade
- **StateFlow** (n√£o LiveData) para streams reativos

---

## üìê ARQUITETURA OBRIGAT√ìRIA

### Stack Principal

```yaml
# WindSurf: Stack tecnol√≥gico imut√°vel
tech_stack:
  language: "Kotlin 1.9.20"
  architecture: "MVVM"
  di_framework: "Hilt 2.51"
  database: "Room (offline-first)"
  backend: "Firebase (Firestore + Auth)"
  async: "Coroutines + StateFlow"
  navigation: "Navigation Component"
  build: "Gradle 8.2 (.bat sempre)"
```

### M√≥dulos do Projeto

```yaml
# WindSurf: Estrutura de m√≥dulos
project_modules:
  app: "M√≥dulo principal e configura√ß√£o"
  core: "Utilit√°rios compartilhados"
  data: "Camada de dados (Room + Firebase)"
  ui: "Camada de apresenta√ß√£o (Fragments + ViewModels)"
  sync: "Sincroniza√ß√£o offline-first"

# Regra: N√ÉO quebrar estrutura de m√≥dulos
```

---

## üé≠ CAMADA DE APRESENTA√á√ÉO (UI)

### ViewModels (Padr√£o Obrigat√≥rio)

```kotlin
// WindSurf: Template ViewModel
@HiltViewModel
class [Nome]ViewModel @Inject constructor(
    private val repository: [Nome]Repository,
    private val userSessionManager: UserSessionManager
) : ViewModel() {
    
    // StateFlow obrigat√≥rio (n√£o LiveData)
    private val _uiState = MutableStateFlow([Nome]UiState.Initial)
    val uiState: StateFlow<[Nome]UiState> = _uiState.asStateFlow()
    
    // Logs estruturados obrigat√≥rios
    private companion object {
        private const val TAG = "[DIAGNOSTICO]"
    }
    
    // Valida√ß√£o de multi-tenancy
    fun executarAcao(dados: Dados) {
        if (!userSessionManager.canAccessRota(dados.rota_id)) {
            Log.w(TAG, "Acesso negado √† rota: ${dados.rota_id}")
            return
        }
        
        Log.d(TAG, "INICIANDO executarAcao")
        // ... implementa√ß√£o
    }
}
```

### Fragments (Padr√£o Obrigat√≥rio)

```kotlin
// WindSurf: Template Fragment
@AndroidEntryPoint
class [Nome]Fragment : Fragment() {
    
    private val viewModel: [Nome]ViewModel by viewModels()
    private var _binding: Fragment[Nome]Binding? = null
    private val binding get() = _binding!!
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        // Observar StateFlow (n√£o LiveData)
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.uiState
                .flowWithLifecycle(viewLifecycleOwner.lifecycle)
                .collect { state ->
                    when (state) {
                        is [Nome]UiState.Success -> updateUI(state.data)
                        is [Nome]UiState.Error -> showError(state.message)
                        [Nome]UiState.Loading -> showLoading()
                    }
                }
        }
    }
}
```

### Valida√ß√µes de UI

```yaml
# WindSurf: Valida√ß√µes autom√°ticas de UI
ui_validations:
  required:
    - "@AndroidEntryPoint em Fragments"
    - "@HiltViewModel em ViewModels"
    - "StateFlow ao inv√©s de LiveData"
    - "flowWithLifecycle para observa√ß√£o"
    
  forbidden:
    - "Acesso direto a DAOs"
    - "Acesso direto a Firebase"
    - "LiveData em novos componentes"
    - "ViewModels sem inje√ß√£o"
```

---

## üóÑÔ∏è CAMADA DE DADOS (DATA)

### Entities (Multi-tenancy Obrigat√≥rio)

```kotlin
// WindSurf: Template Entity com multi-tenancy
@Entity(tableName = "[nome]")
data class [Nome]Entity(
    @PrimaryKey val id: String,
    
    // Campos OBRIGAT√ìRIOS de multi-tenancy
    val empresa_id: String,
    val rota_id: String,
    
    // Campo OBRIGAT√ìRIO para sync
    val dataUltimaAtualizacao: Long = System.currentTimeMillis(),
    
    // Campos de neg√≥cio
    val nome: String,
    val ativo: Boolean = true,
    
    // Campos opcionais
    val descricao: String? = null
) {
    // Valida√ß√µes no construtor
    init {
        require(empresa_id.isNotBlank()) { "empresa_id obrigat√≥rio" }
        require(rota_id.isNotBlank()) { "rota_id obrigat√≥rio" }
    }
}
```

### DAOs (Padr√£o Obrigat√≥rio)

```kotlin
// WindSurf: Template DAO
@Dao
interface [Nome]Dao {
    
    // Query principal sempre com filtro de rota
    @Query("SELECT * FROM [nome] WHERE rota_id = :rotaId AND ativo = 1")
    fun getByRota(rotaId: String): Flow<List<[Nome]Entity>>
    
    // Busca por ID (sempre verificar rota)
    @Query("SELECT * FROM [nome] WHERE id = :id AND rota_id = :rotaId")
    suspend fun getById(id: String, rotaId: String): [Nome]Entity?
    
    // Inserir com conflito
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(entity: [Nome]Entity): Long
    
    // Atualizar timestamp
    @Query("UPDATE [nome] SET dataUltimaAtualizacao = :timestamp WHERE id = :id")
    suspend fun updateTimestamp(id: String, timestamp: Long = System.currentTimeMillis())
    
    // Soft delete (n√£o deletar fisicamente)
    @Query("UPDATE [nome] SET ativo = 0 WHERE id = :id AND rota_id = :rotaId")
    suspend fun softDelete(id: String, rotaId: String)
}
```

### Repositories (Interface + Implementa√ß√£o)

```kotlin
// WindSurf: Interface Repository
interface [Nome]Repository {
    fun getByRota(rotaId: String): Flow<List<[Nome]>>
    suspend fun getById(id: String, rotaId: String): [Nome]?
    suspend fun save(entity: [Nome]): Result<[Nome]>
    suspend fun delete(id: String, rotaId: String): Result<Unit>
}

// WindSurf: Implementa√ß√£o Repository
@Singleton
class [Nome]RepositoryImpl @Inject constructor(
    private val dao: [Nome]Dao,
    private val firestore: FirebaseFirestore,
    private val syncRepository: SyncRepository,
    private val userSessionManager: UserSessionManager
) : [Nome]Repository {
    
    override fun getByRota(rotaId: String): Flow<List<[Nome]>> = flow {
        // 1. Emitir local imediatamente (offline-first)
        val local = dao.getByRota(rotaId).first()
        emit(local.map { it.toDomain() })
        
        // 2. Sync em background se online
        if (networkUtils.isConnected()) {
            syncFromFirestore(rotaId)
        }
    }
    
    private suspend fun syncFromFirestore(rotaId: String) {
        // Valida√ß√£o de multi-tenancy
        if (!userSessionManager.canAccessRota(rotaId)) {
            throw SecurityException("Acesso negado √† rota: $rotaId")
        }
        
        // Sync com Firestore
        val empresaId = userSessionManager.getCurrentEmpresaId()
        val collection = firestore
            .collection("empresas")
            .document(empresaId)
            .collection("entidades")
            .collection("[nome]")
            .whereEqualTo("rota_id", rotaId)
            
        val documents = collection.get().await()
        // ... processar documentos
    }
}
```

---

## üîß INJE√á√ÉO DE DEPEND√äNCIAS (HILT)

### Modules Obrigat√≥rios

```kotlin
// WindSurf: Module de Repositories
@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {
    
    @Binds
    @Singleton
    abstract fun bind[Nome]Repository(
        impl: [Nome]RepositoryImpl
    ): [Nome]Repository
    
    // AppRepository √© FACADE - N√ÉO refatorar
    @Binds
    @Singleton
    abstract fun bindAppRepository(
        impl: AppRepositoryImpl
    ): AppRepository
}

// WindSurf: Module de DAOs
@Module
@InstallIn(SingletonComponent::class)
object DaoModule {
    
    @Provides
    @Singleton
    fun provide[Nome]Dao(database: AppDatabase): [Nome]Dao {
        return database.[nome]Dao()
    }
}
```

### Application com Hilt

```kotlin
// WindSurf: Application configurada
@HiltAndroidApp
class GestaoBilharesApplication : Application() {
    
    override fun onCreate() {
        super.onCreate()
        
        // Configurar WorkManager para sync
        configureWorkManager()
        
        // Inicializar logs estruturados
        configureLogging()
    }
    
    private fun configureWorkManager() {
        // SyncWorker configurado para 6 horas
        val constraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .setRequiresBatteryNotLow(true)
            .setRequiresCharging(true)
            .build()
            
        val syncRequest = PeriodicWorkRequestBuilder<SyncWorker>(
            6, TimeUnit.HOURS
        ).setConstraints(constraints).build()
        
        WorkManager.getInstance(this)
            .enqueueUniquePeriodicWork(
                "sync_worker",
                ExistingPeriodicWorkPolicy.KEEP,
                syncRequest
            )
    }
}
```

---

## üîê MULTI-TENANCY (OBRIGAT√ìRIO)

### Valida√ß√£o de Acesso

```kotlin
// WindSurf: UserSessionManager com valida√ß√µes
@Singleton
class UserSessionManager @Inject constructor(
    private val auth: FirebaseAuth,
    private val firestore: FirebaseFirestore
) {
    
    fun canAccessRota(rotaId: String): Boolean {
        val currentUser = auth.currentUser ?: return false
        val rotasPermitidas = getRotasPermitidas()
        return rotasPermitidas.contains(rotaId)
    }
    
    fun canManageCollaboradores(): Boolean {
        val nivel = getNivelAcesso()
        return nivel == "ADMIN"
    }
    
    fun getCurrentEmpresaId(): String {
        // Buscar dos claims do Firebase Auth
        return auth.currentUser?.let { user ->
            // Implementar busca de empresa_id
            "empresa001" // Tempor√°rio
        } ?: throw SecurityException("Usu√°rio n√£o autenticado")
    }
    
    fun getRotasPermitidas(): List<String> {
        // Buscar dos claims ou Firestore
        return auth.currentUser?.let { user ->
            // Implementar busca de rotasPermitidas
            listOf("037-Salinas", "034-Bonito") // Tempor√°rio
        } ?: emptyList()
    }
}
```

### Firestore Path (Padr√£o Obrigat√≥rio)

```kotlin
// WindSurf: Path padr√£o Firestore
object FirestorePaths {
    
    fun getEntityPath(empresaId: String, collection: String, itemId: String): String {
        return "empresas/$empresaId/entidades/$collection/items/$itemId"
    }
    
    fun getCollectionPath(empresaId: String, collection: String): String {
        return "empresas/$empresaId/entidades/$collection/items"
    }
    
    // Exemplos:
    // Cliente: empresas/empresa001/entidades/clientes/items/cliente001
    // Acerto: empresas/empresa001/entidades/acertos/items/acerto001
    // Mesa:   empresas/empresa001/entidades/mesas/items/mesa001
}
```

### Security Rules (Valida√ß√£o)

```javascript
// WindSurf: Security Rules com multi-tenancy
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function para validar rota
    function belongsToUserRoute(empresaId, rotaId) {
      return request.auth != null &&
             request.auth.token.empresa_id == empresaId &&
             request.auth.token.rotasPermitidas.contains(rotaId);
    }
    
    // Entidades com multi-tenancy
    match /empresas/{empresaId}/entidades/{collection}/items/{itemId} {
      allow read, write: if belongsToUserRoute(empresaId, resource.data.rota_id);
      allow create: if belongsToUserRoute(empresaId, request.resource.data.rota_id);
    }
    
    // Colaboradores
    match /empresas/{empresaId}/colaboradores/{uid} {
      allow read, write: if request.auth != null &&
                          request.auth.token.empresa_id == empresaId &&
                          request.auth.uid == uid;
    }
  }
}
```

---

## üîÑ OFFLINE-FIRST (OBRIGAT√ìRIO)

### Estrat√©gia Cache-First

```kotlin
// WindSurf: Repository com cache-first
class [Nome]RepositoryImpl @Inject constructor(
    private val dao: [Nome]Dao,
    private val firestore: FirebaseFirestore,
    private val networkUtils: NetworkUtils
) {
    
    fun getAll(rotaId: String): Flow<List<[Nome]>> = flow {
        // 1. Emitir local imediatamente
        val local = dao.getByRota(rotaId).first()
        emit(local.map { it.toDomain() })
        
        // 2. Sync em background se online
        if (networkUtils.isConnected()) {
            try {
                val remotos = fetchFromFirestore(rotaId)
                dao.insertAll(remotos.map { it.toEntity() })
                
                // 3. Emitir dados atualizados
                val atualizados = dao.getByRota(rotaId).first()
                emit(atualizados.map { it.toDomain() })
            } catch (e: Exception) {
                // Falha silenciosa - usa cache
                Log.w("[SYNC]", "Falha sync, usando cache", e)
            }
        }
    }
}
```

### Sync Operations

```kotlin
// WindSurf: SyncOperation para fila offline
@Entity(tableName = "sync_operations")
data class SyncOperation(
    @PrimaryKey val id: String = UUID.randomUUID().toString(),
    val entityType: String,
    val entityId: String,
    val operation: String, // CREATE, UPDATE, DELETE
    val data: String, // JSON dos dados
    val status: String = "PENDING", // PENDING, PROCESSING, SUCCESS, FAILED
    val retryCount: Int = 0,
    val maxRetries: Int = 3,
    val lastError: String? = null,
    val createdAt: Long = System.currentTimeMillis(),
    val processedAt: Long? = null,
    
    // Multi-tenancy
    val empresa_id: String,
    val rota_id: String
)
```

---

## üìä VALIDA√á√ïES AUTOM√ÅTICAS

### WindSurf: Checks de Arquitetura

```yaml
# WindSurf: Valida√ß√µes autom√°ticas ao criar/modificar arquivos
architecture_validations:
  viewmodel_checks:
    required:
      - "@HiltViewModel"
      - "@Inject constructor"
      - "StateFlow (n√£o LiveData)"
      - "Logs com [TAG]"
    forbidden:
      - "Acesso direto a DAO"
      - "Acesso direto a Firebase"
      
  entity_checks:
    required:
      - "@Entity"
      - "empresa_id: String"
      - "rota_id: String"
      - "dataUltimaAtualizacao: Long"
    validations:
      - "require() nos campos obrigat√≥rios"
      
  repository_checks:
    required:
      - "Interface + Implementa√ß√£o"
      - "@Inject constructor"
      - "Flow para streams"
      - "Valida√ß√£o de rota_id"
      
  fragment_checks:
    required:
      - "@AndroidEntryPoint"
      - "viewModels() delegation"
      - "flowWithLifecycle"
      - "StateFlow observation"
```

### Valida√ß√µes de Build

```yaml
# WindSurf: Valida√ß√µes autom√°ticas no build
build_validations:
  pre_build:
    - "Verificar .bat no comando"
    - "Validar imports Hilt"
    - "Checar multi-tenancy"
    
  post_build:
    - "Verificar warnings"
    - "Validar test coverage"
    - "Checar performance"
    
  failure_analysis:
    - "Identificar tipo de erro"
    - "Sugerir corre√ß√£o"
    - "Verificar se √© loop"
```

---

## üéØ SNIPPETS AUTOM√ÅTICOS

### ViewModel Completo

```bash
# WindSurf: Gerar ViewModel completo
/wind arch viewmodel [Nome]

# Gera:
@HiltViewModel
class [Nome]ViewModel @Inject constructor(
    private val repository: [Nome]Repository,
    private val userSessionManager: UserSessionManager
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<[Nome]UiState>.Initial)
    val uiState: StateFlow<[Nome]UiState> = _uiState.asStateFlow()
    
    private companion object {
        private const val TAG = "[DIAGNOSTICO]"
    }
}
```

### Entity com Multi-tenancy

```bash
# WindSurf: Gerar Entity completa
/wind arch entity [Nome]

# Gera:
@Entity(tableName = "[nome]")
data class [Nome]Entity(
    @PrimaryKey val id: String,
    val empresa_id: String,
    val rota_id: String,
    val dataUltimaAtualizacao: Long = System.currentTimeMillis()
) {
    init {
        require(empresa_id.isNotBlank()) { "empresa_id obrigat√≥rio" }
        require(rota_id.isNotBlank()) { "rota_id obrigat√≥rio" }
    }
}
```

### Repository Pattern

```bash
# WindSurf: Gerar Repository completo
/wind arch repository [Nome]

# Gera interface + implementa√ß√£o com:
# - Cache-first strategy
# - Multi-tenancy validation
# - Offline-first sync
# - Error handling
```

---

## üìã CHECKLIST FINAL

### Valida√ß√£o de Componentes

```yaml
# WindSurf: Checklist obrigat√≥rio para cada componente
component_validation:
  viewmodel:
    - [ ] @HiltViewModel presente
    - [ ] @Inject constructor correto
    - [ ] StateFlow usado (n√£o LiveData)
    - [ ] Logs com [TAG] estruturados
    - [ ] Valida√ß√£o de multi-tenancy
    - [ ] Sem acesso direto a DAO/Firebase
    
  entity:
    - [ ] @Entity annotation
    - [ ] empresa_id presente
    - [ ] rota_id presente
    - [ ] dataUltimaAtualizacao presente
    - [ ] require() nos campos obrigat√≥rios
    - [ ] PrimaryKey definido
    
  repository:
    - [ ] Interface + Implementa√ß√£o
    - [ ] @Inject constructor
    - [ ] Flow para streams reativos
    - [ ] Cache-first strategy
    - [ ] Valida√ß√£o de rota_id
    - [ ] Error handling adequado
    
  fragment:
    - [ ] @AndroidEntryPoint
    - [ ] viewModels() delegation
    - [ ] flowWithLifecycle
    - [ ] StateFlow observation
    - [ ] Sem binding direto de dados
```

### Valida√ß√£o de Arquitetura

```yaml
# WindSurf: Valida√ß√£o geral da arquitetura
architecture_validation:
  mvvm:
    - [ ] ViewModels ‚Üí Repositories ‚Üí DAOs
    - [ ] UI n√£o acessa dados diretamente
    - [ ] Separa√ß√£o clara de responsabilidades
    
  di:
    - [ ] Hilt configurado
    - [ ] @Inject usado consistentemente
    - [ ] Modules bem definidos
    - [ ] Sem inje√ß√£o manual
    
  multi_tenancy:
    - [ ] rota_id em todas entities
    - [ ] Valida√ß√£o de acesso
    - [ ] Firestore path correto
    - [ ] Security rules atualizadas
    
  offline_first:
    - [ ] Room como fonte da verdade
    - [ ] Cache-first strategy
    - [ ] Sync operations funcionando
    - [ ] WorkManager configurado
```

---

## üöÄ BENEF√çCIOS

### Para IAs
- **Arquitetura padronizada:** Sem varia√ß√£o
- **Valida√ß√µes autom√°ticas:** Qualidade garantida
- **Snippets inteligentes:** Desenvolvimento r√°pido
- **Zero configura√ß√£o:** Tudo pronto

### Para Humanos
- **C√≥digo consistente:** Padr√µes mantidos
- **Facilidade de manuten√ß√£o:** Arquitetura clara
- **Qualidade assegurada:** Valida√ß√µes autom√°ticas
- **Produtividade:** Ferramentas auxiliares

### Para Projeto
- **Evolu√ß√£o segura:** Base s√≥lida
- **Multi-tenancy robusto:** Isolamento garantido
- **Offline-first:** Funciona sem internet
- **Performance:** Cache e otimiza√ß√µes

---

*Arquitetura configurada e validada para desenvolvimento eficiente.*
