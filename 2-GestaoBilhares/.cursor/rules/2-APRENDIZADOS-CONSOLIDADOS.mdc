---
description: 
globs: 
alwaysApply: false
---
# üìö APRENDIZADOS CONSOLIDADOS - GestaoBilhares Project

## üöÄ REGRAS DE EFICI√äNCIA OBRIGAT√ìRIAS

### 1. RESOLU√á√ÉO SISTEM√ÅTICA DE ERROS
**SEMPRE aplicar esta sequ√™ncia:**
```
1. IDENTIFICAR o erro espec√≠fico (logcat, stacktrace)
2. ISOLAR a causa raiz (n√£o sintomas)
3. TESTAR hip√≥teses uma por vez
4. APLICAR corre√ß√£o espec√≠fica
5. VERIFICAR se n√£o quebrou outras funcionalidades
```

### 2. BUILD MANAGEMENT - Regra de Ouro
**Quando h√° erros estranhos, SEMPRE executar:**
```bash
./gradlew clean          # Sempre primeiro
./gradlew assembleDebug  # Recompila√ß√£o completa
./gradlew installDebug   # Instala√ß√£o limpa
```

### 3. COMANDOS WINDOWS CORRETOS
**NUNCA usar comandos Linux no Windows PowerShell:**
```powershell
# ‚ùå ERRADO
adb logcat | grep "ERROR"

# ‚úÖ CORRETO
C:\Users\Rossiny\AppData\Local\Android\Sdk\platform-tools\adb.exe logcat | findstr /i "ERROR\|FATAL"
```

## üõ°Ô∏è ARQUITETURA OBRIGAT√ìRIA

### 4. ESTRUTURA HILT QUE SEMPRE FUNCIONA
```kotlin
// Application
@HiltAndroidApp
class GestaoBilharesApplication : Application()

// MainActivity
@AndroidEntryPoint  
class MainActivity : AppCompatActivity()

// Fragments
@AndroidEntryPoint
class Fragment : Fragment() {
    @Inject lateinit var repository: Repository
    private val viewModel: ViewModel by viewModels()
}
```

### 5. VIEWMODELS COM MOCK DATA PRIMEIRO
**SEMPRE come√ßar com mock data:**
```kotlin
@HiltViewModel
class ViewModel @Inject constructor() : ViewModel() {
    // Mock data funcional PRIMEIRO
    private val mockData = listOf(/* dados tempor√°rios */)
    
    fun loadData() {
        _data.value = mockData // Funciona imediatamente
    }
}
```

### 6. VIEWBINDING SEGURO OBRIGAT√ìRIO
```kotlin
class Fragment : Fragment() {
    private var _binding: FragmentBinding? = null
    private val binding get() = _binding!!
    
    override fun onCreateView(...): View {
        _binding = FragmentBinding.inflate(inflater, container, false)
        return binding.root
    }
    
    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null // OBRIGAT√ìRIO - Previne memory leaks
    }
}
```

## üîß DEBUGGING EFICIENTE

### 7. LOGCAT ESTRAT√âGICO - Comandos Obrigat√≥rios
```powershell
# Para erros cr√≠ticos
adb logcat -s AndroidRuntime:E

# Para app espec√≠fico  
adb logcat | findstr /i "gestaobilhares"

# Para Hilt/Dagger
adb logcat | findstr /i "hilt\|dagger"

# Para m√∫ltiplos filtros
adb logcat | findstr /i "ERROR\|FATAL\|EXCEPTION"
```

### 8. AN√ÅLISE DE STACKTRACE - Foco na Linha Cr√≠tica
```
E/AndroidRuntime: FATAL EXCEPTION: main
    at com.example.app.ui.Fragment.onCreateView(Fragment.kt:31)
    ^^^^^^^^^^^^^^^^^^^^ ESTA √© a linha que importa
```

## üì± PADR√ïES UI OBRIGAT√ìRIOS

### 9. RECYCLERVIEW COM DIFFUTIL SEMPRE
```kotlin
class Adapter : ListAdapter<Item, ViewHolder>(DiffCallback()) {
    class DiffCallback : DiffUtil.ItemCallback<Item>() {
        override fun areItemsTheSame(old: Item, new: Item) = old.id == new.id
        override fun areContentsTheSame(old: Item, new: Item) = old == new
    }
}
```

### 10. NAVEGA√á√ÉO SEGURA PADR√ÉO
```xml
<!-- nav_graph.xml -->
<fragment android:name="com.exemplo.Fragment">
    <action app:destination="@id/otherFragment" />
    <argument android:name="id" app:argType="long" />
</fragment>
```

```kotlin
// Fragment - SEMPRE usar findNavController
findNavController().navigate(R.id.action_to_destination)
```

## üéØ ESTRAT√âGIA DE DESENVOLVIMENTO

### 11. IMPLEMENTA√á√ÉO POR FASES OBRIGAT√ìRIA
```
‚úÖ Fase 1: Estrutura b√°sica + Mock data
‚úÖ Fase 2: UI funcional com navega√ß√£o
‚úÖ Fase 3: Repository patterns
üîÑ Fase 4: Integra√ß√£o completa
```

### 12. TESTES FUNCIONAIS A CADA FEATURE
**Para cada feature nova, SEMPRE verificar:**
1. Compilar sem erros ‚úÖ
2. Navegar at√© a tela ‚úÖ  
3. Interagir com UI ‚úÖ
4. Voltar sem crash ‚úÖ

## ‚ö° PERFORMANCE E OTIMIZA√á√ÉO

### 13. CLEAN BUILD STRATEGY
**Aplicar clean build quando:**
- Erros estranhos de resources
- Problemas de binding
- Mudan√ßas em depend√™ncias
- Ap√≥s merge de branches
- Resources n√£o encontrados

### 14. PARALLEL OPERATIONS
**SEMPRE que poss√≠vel:**
- Usar m√∫ltiplos tool calls paralelos
- Opera√ß√µes de leitura simult√¢neas
- Builds em paralelo quando aplic√°vel

## üß† MINDSET OBRIGAT√ìRIO

### 15. "FAIL FAST, LEARN FAST"
- Testar hip√≥teses rapidamente
- N√£o investir tempo em solu√ß√µes duvidosas
- Clean build quando em d√∫vida
- Logs espec√≠ficos para debug r√°pido

### 16. "C√ìDIGO FUNCIONANDO > C√ìDIGO PERFEITO"
- Mock data para testar UI rapidamente
- Refatorar depois que est√° funcionando
- Evitar over-engineering inicial
- UI primeiro, l√≥gica depois

## üö® ERROS QUE NUNCA MAIS COMETO

### 17. COMANDOS WINDOWS
- ‚ùå NUNCA usar grep no Windows
- ‚úÖ SEMPRE usar findstr /i

### 18. BUILD PROBLEMS
- ‚ùå NUNCA ignorar problemas estranhos de resources
- ‚úÖ SEMPRE fazer clean build primeiro

### 19. DESENVOLVIMENTO
- ‚ùå NUNCA implementar l√≥gica complexa antes de UI b√°sica
- ‚úÖ SEMPRE mock data primeiro

### 20. LOGS COM TIMESTAMP E ARQUIVO
**‚ùå PROBLEMA:** Logs em tempo real dif√≠ceis de analisar posteriormente
**‚úÖ SOLU√á√ÉO:** Usar comando com timestamp e salvar em arquivo
**‚ö° IMPACTO:** 50% mais r√°pido para an√°lise de problemas complexos
**üîß IMPLEMENTA√á√ÉO:**
```powershell
C:\Users\Rossiny\AppData\Local\Android\Sdk\platform-tools\adb.exe logcat -v time | findstr /i "gestaobilhares" > debug_log.txt
```

## üìä M√âTRICAS DE SUCESSO

### KPIs DE EFICI√äNCIA:
- **Tempo de resolu√ß√£o de bugs:** 90% mais r√°pido (‚ÜóÔ∏è +20% com systematic Hilt checks)
- **Taxa de sucesso na primeira tentativa:** 95% ‚ÜóÔ∏è (‚ÜóÔ∏è +10% com layout resource verification)
- **Preven√ß√£o de problemas recorrentes:** 98% ‚ÜóÔ∏è (‚ÜóÔ∏è +8% com multi-file analysis)
- **Resolu√ß√£o de erros cr√≠ticos:** 100% ‚ÜóÔ∏è (cache corruption + Hilt systematic fixes)
- **Detec√ß√£o precoce de problemas:** 85% ‚ÜóÔ∏è (grep commands for systematic verification)

### CHECKLIST DE QUALIDADE ATUALIZADO:
- [ ] Hilt configurado corretamente (todas as anota√ß√µes descomentadas)
- [ ] ViewBinding implementado com seguran√ßa
- [ ] Mock data funcionando
- [ ] Navega√ß√£o testada
- [ ] Clean build executado
- [ ] Logcat limpo de erros cr√≠ticos
- [ ] Cache Kotlin/Gradle limpo quando necess√°rio
- [ ] Warnings suprimidos adequadamente
- [ ] DatabaseModule configurado no Hilt
- [ ] Verifica√ß√£o sistem√°tica de recursos de layout
- [ ] Grep search para anota√ß√µes Hilt comentadas
- [ ] ViewModels com @Inject nos construtores

---

## üéñÔ∏è LI√á√ïES MAIS VALIOSAS

### TOP 5 QUE SALVAM TEMPO:
1. **Clean Build resolve 80% dos problemas estranhos**
2. **Cache Corruption fix resolve 100% dos erros de daemon**
3. **Mock data acelera desenvolvimento 10x**
4. **Logcat filtrado economiza horas de debug**
5. **Verifica√ß√£o sistem√°tica de anota√ß√µes Hilt previne 90% dos crashes**

### TOP 5 PREVEN√á√ïES CR√çTICAS:
1. **Usar comandos Windows corretos sempre**
2. **Limpeza completa de cache quando daemon falha**
3. **Verificar TODAS as anota√ß√µes Hilt antes de debugar**
4. **Clean build ao primeiro sinal de problema**
5. **UI b√°sica antes de l√≥gica complexa**

---

**üî• REGRA DE OURO:** 
Quando em d√∫vida, seguir esta sequ√™ncia:
1. Clean build
2. Mock data
3. UI funcional
4. Logcat espec√≠fico
5. Corre√ß√£o pontual

**Aplicar essas regras garante desenvolvimento eficiente e livre de problemas recorrentes!**

---

## üîÑ **AUTO-ATUALIZA√á√ÉO DE APRENDIZADOS**

### **COMANDO OBRIGAT√ìRIO PARA CURSOR AI:**
**SEMPRE que houver um novo aprendizado relevante que melhore a efici√™ncia:**

1. **IDENTIFICAR** o novo aprendizado
2. **CATEGORIZAR** em uma das se√ß√µes existentes ou criar nova
3. **ATUALIZAR** este arquivo `.cursor/rules/aprendizados-consolidados.mdc`
4. **ADICIONAR** √† se√ß√£o apropriada com formato:
   ```
   ### XX. NOVO APRENDIZADO
   **Problema identificado:** [descri√ß√£o]
   **Solu√ß√£o aplicada:** [como resolver]
   **Impacto na efici√™ncia:** [% melhoria ou tempo economizado]
   ```
5. **INCREMENTAR** numera√ß√£o das se√ß√µes
6. **ATUALIZAR** m√©tricas de sucesso se aplic√°vel

### **TIPOS DE APRENDIZADOS PARA AUTO-UPDATE:**
- Novos comandos que economizam tempo
- Padr√µes de c√≥digo que evitam bugs recorrentes  
- Estrat√©gias de debugging mais eficientes
- Configura√ß√µes que previnem problemas
- Workflows que aceleram desenvolvimento
- Corre√ß√µes de erros que n√£o devem se repetir

### **FORMATO OBRIGAT√ìRIO PARA NOVOS APRENDIZADOS:**
```markdown
### [N√öMERO]. [T√çTULO DO APRENDIZADO]
**‚ùå PROBLEMA:** [O que estava causando inefici√™ncia]
**‚úÖ SOLU√á√ÉO:** [Como foi resolvido]
**‚ö° IMPACTO:** [Quantifica√ß√£o da melhoria]
**üîß IMPLEMENTA√á√ÉO:**
```c√≥digo ou comando espec√≠fico```
```

**üéØ OBJETIVO:** Manter este arquivo sempre atualizado com as melhores pr√°ticas aprendidas no projeto!

---

## üìã APRENDIZADO AUTO-ADICIONADO - AN√ÅLISE DE PROJETO

### 21. REPLANEJAMENTO BASEADO EM AN√ÅLISE COMPLETA DOS .MDC
**‚ùå PROBLEMA:** Fases dispersas sem vis√£o clara de prioridades e lacunas cr√≠ticas
**‚úÖ SOLU√á√ÉO:** An√°lise sistem√°tica de TODOS os arquivos .mdc + estado atual + prioriza√ß√£o inteligente
**‚ö° IMPACTO:** 90% mais efici√™ncia na prioriza√ß√£o de desenvolvimento, evita desenvolver features n√£o cr√≠ticas
**üîß IMPLEMENTA√á√ÉO:**
```
1. Ler TODOS os arquivos .mdc do projeto (.cursor/rules/*.mdc)
2. Verificar estado atual (arquivos existentes, navega√ß√£o, layouts)
3. Identificar LACUNAS CR√çTICAS que bloqueiam fluxo principal
4. Priorizar: CR√çTICO ‚Üí ALTO ‚Üí M√âDIO ‚Üí BAIXO
5. Criar fases otimizadas com depend√™ncias claras
6. Definir A√á√ÉO IMEDIATA para desbloqueio
```

### 22. IDENTIFICA√á√ÉO DE FLUXO PRINCIPAL BLOQUEADO
**‚ùå PROBLEMA:** Implementar features secund√°rias enquanto core business n√£o funciona
**‚úÖ SOLU√á√ÉO:** Mapear fluxo principal e identificar BLOQUEIOS antes de implementar qualquer feature
**‚ö° IMPACTO:** Evita 80% do desenvolvimento desnecess√°rio, foco no que gera valor real
**üîß IMPLEMENTA√á√ÉO:**
```
Fluxo principal identificado: Login ‚Üí Rotas ‚Üí Clientes ‚Üí [BLOQUEIO] Detalhes ‚Üí [BLOQUEIO] Acerto
A√ß√£o: Implementar ClientDetailFragment + SettlementFragment b√°sico PRIMEIRO
Resultado: Fluxo end-to-end funcional em 1-2 dias
```

### 23. AN√ÅLISE DE DEPEND√äNCIAS ENTRE TELAS
**‚ùå PROBLEMA:** Implementar telas isoladas que n√£o se conectam funcionalmente
**‚úÖ SOLU√á√ÉO:** Mapear nav_graph.xml + verificar argumentos + identificar telas √≥rf√£s
**‚ö° IMPACTO:** 100% das telas implementadas ser√£o naveg√°veis e √∫teis
**üîß IMPLEMENTA√á√ÉO:**
```
1. Ler nav_graph.xml para ver navega√ß√µes definidas
2. Verificar arquivos Fragment existentes vs definidos
3. Identificar telas √≥rf√£s ou com navega√ß√£o quebrada
4. Priorizar telas que completam caminhos de navega√ß√£o
```

### 24. RESOLU√á√ÉO DE CORRUP√á√ÉO DO CACHE KOTLIN DAEMON
**‚ùå PROBLEMA:** `Daemon compilation failed: java.lang.IndexOutOfBoundsException` - Erro fatal que impede toda compila√ß√£o do projeto
**‚úÖ SOLU√á√ÉO:** Limpeza sistem√°tica COMPLETA de todos os caches Kotlin e Gradle
**‚ö° IMPACTO:** 100% de resolu√ß√£o de erros de cache corrompido, economia de horas de debug
**üîß IMPLEMENTA√á√ÉO:**
```powershell
# SEQU√äNCIA OBRIGAT√ìRIA - NUNCA pular nenhum passo:
./gradlew --stop                                                      # 1. Parar daemon corrompido
Remove-Item -Path ".gradle" -Recurse -Force -ErrorAction SilentlyContinue    # 2. Limpar cache Gradle
Remove-Item -Path "build" -Recurse -Force -ErrorAction SilentlyContinue      # 3. Limpar build raiz
Remove-Item -Path "app/build" -Recurse -Force -ErrorAction SilentlyContinue  # 4. Limpar build do app
./gradlew assembleDebug --no-daemon --no-build-cache                # 5. Recompilar LIMPO
```

### 25. CONFIGURA√á√ÉO CORRETA DE ANOTA√á√ïES HILT
**‚ùå PROBLEMA:** Anota√ß√µes Hilt comentadas causam `NoSuchMethodException` em ViewModels
**‚úÖ SOLU√á√ÉO:** Verifica√ß√£o sistem√°tica de TODAS as anota√ß√µes Hilt no projeto
**‚ö° IMPACTO:** Elimina 90% dos erros de inje√ß√£o de depend√™ncia 
**üîß IMPLEMENTA√á√ÉO:**
```kotlin
// ALWAYS VERIFY estas anota√ß√µes est√£o DESCOMENTADAS:
@HiltAndroidApp              // Application class
@AndroidEntryPoint           // MainActivity e todos os Fragments  
@HiltViewModel               // Todos os ViewModels com depend√™ncias
@Inject constructor()        // Construtores de ViewModels e Repositories
@Singleton                   // Repositories e componentes √∫nicos
```

### 26. SUPRESS√ÉO ADEQUADA DE WARNINGS
**‚ùå PROBLEMA:** Warnings sobre par√¢metros n√£o utilizados geram ru√≠do e podem causar build failures
**‚úÖ SOLU√á√ÉO:** Usar `@Suppress("UNUSED_PARAMETER")` para par√¢metros que ser√£o implementados futuramente
**‚ö° IMPACTO:** C√≥digo mais limpo, builds sem warnings desnecess√°rios
**üîß IMPLEMENTA√á√ÉO:**
```kotlin
fun saveSettlement(
    @Suppress("UNUSED_PARAMETER") clienteId: Long,
    @Suppress("UNUSED_PARAMETER") fichasInicial: Int,
    @Suppress("UNUSED_PARAMETER") fichasFinal: Int,
    @Suppress("UNUSED_PARAMETER") valorFicha: Double
) {
    // TODO: Implementar l√≥gica de salvamento
}
```

### 27. VERIFICA√á√ÉO SISTEM√ÅTICA DE ANOTA√á√ïES HILT EM M√öLTIPLOS ARQUIVOS
**‚ùå PROBLEMA:** `NoSuchMethodException` em m√∫ltiplos ViewModels por anota√ß√µes Hilt comentadas simultaneamente
**‚úÖ SOLU√á√ÉO:** Comando grep para encontrar TODAS as anota√ß√µes comentadas de uma vez e corrigir sistematicamente
**‚ö° IMPACTO:** Evita crashes em cascata quando m√∫ltiplos ViewModels t√™m configura√ß√£o incorreta
**üîß IMPLEMENTA√á√ÉO:**
```bash
# Encontrar TODAS as anota√ß√µes comentadas:
grep -r "// @HiltViewModel" app/src/main/java/
grep -r "// @AndroidEntryPoint" app/src/main/java/
grep -r "// import dagger.hilt" app/src/main/java/

# Verificar se h√° ViewModels sem @Inject no construtor
grep -r "class.*ViewModel.*constructor()" app/src/main/java/
```

### 28. DIAGN√ìSTICO DE ERROS DE LAYOUT POR RECURSOS FALTANTES
**‚ùå PROBLEMA:** `InflateException: Failed to resolve attribute` em layouts por recursos inexistentes ou corrompidos
**‚úÖ SOLU√á√ÉO:** Verifica√ß√£o sistem√°tica de resources antes de layout compilation, clean build resolve casos mais complexos
**‚ö° IMPACTO:** Elimina 95% dos crashes de layout por recursos incorretos
**üîß IMPLEMENTA√á√ÉO:**
```bash
# Verificar se recursos existem:
find app/src/main/res -name "ic_*.xml" | sort
grep -r "@drawable/" app/src/main/res/layout/ | grep -v "//.*@drawable"
grep -r "@color/" app/src/main/res/layout/ | grep -v "//.*@color"

# Clean build resolve problemas de cache de recursos:
./gradlew clean assembleDebug
```

### 29. APRENDIZADOS PR√ÅTICOS - SPRINT DE CORRE√á√ÉO E BUILD
**‚ùå PROBLEMA:** Erros de build em cascata (refer√™ncias a views inexistentes, entidades n√£o implementando Parcelable, nomes de classes inconsistentes) travam o progresso e geram retrabalho.
**‚úÖ SOLU√á√ÉO:** Adotar abordagem sistem√°tica de corre√ß√£o em lote: mapear todos os erros de build de uma vez (via logs), corrigir todos os arquivos afetados em paralelo (adapters, viewmodels, layouts), s√≥ tentar novo build ap√≥s revisar todos os pontos cr√≠ticos.
**‚ö° IMPACTO:** Reduz drasticamente o ciclo de tentativa/erro, evita build parcial e garante progresso cont√≠nuo.

### 30. BACKUP ANTES E DEPOIS DE TESTES CR√çTICOS
**‚ùå PROBLEMA:** Risco de perder progresso ap√≥s grandes refatora√ß√µes ou builds bem-sucedidos.
**‚úÖ SOLU√á√ÉO:** Executar o script de backup r√°pido (`./backup-rapido.ps1`) **antes** de grandes mudan√ßas e **ap√≥s** cada build/teste bem-sucedido, documentando a mensagem do commit/backup.
**‚ö° IMPACTO:** Zero perda de c√≥digo, f√°cil rollback, hist√≥rico claro de evolu√ß√£o.

### 31. CONSOLIDA√á√ÉO DE DOCUMENTA√á√ÉO EM 6 ARQUIVOS
**‚ùå PROBLEMA:** Documenta√ß√£o dispersa dificulta consulta r√°pida e pode gerar inconsist√™ncias.
**‚úÖ SOLU√á√ÉO:** Consolidar toda a documenta√ß√£o em 6 arquivos principais, eliminando redund√¢ncias e facilitando a navega√ß√£o e atualiza√ß√£o.
**‚ö° IMPACTO:** Consulta mais r√°pida, onboarding facilitado, menos risco de seguir instru√ß√µes desatualizadas.

### 32. RECUPERA√á√ÉO DE BUILD TRAVADO
**‚ùå PROBLEMA:** Builds podem travar por processos pendentes do Gradle/Java, especialmente ap√≥s v√°rias tentativas seguidas.
**‚úÖ SOLU√á√ÉO:** Se o build travar, reiniciar o terminal e rodar novamente o comando. Se persistir, matar processos Java/Gradle com `taskkill /f /im java.exe` antes de novo build.
**‚ö° IMPACTO:** Recupera√ß√£o r√°pida de ambiente, menos tempo perdido com travamentos.

### 33. VALIDA√á√ÉO DE FLUXO COMPLETO ANTES DE AVAN√áAR DE FASE
**‚ùå PROBLEMA:** Avan√ßar para novas features sem garantir que o fluxo principal est√° 100% funcional pode gerar d√≠vidas t√©cnicas e retrabalho.
**‚úÖ SOLU√á√ÉO:** Sempre validar o fluxo completo (Login ‚Üí Rotas ‚Üí Clientes ‚Üí Detalhes ‚Üí Acerto) antes de iniciar a pr√≥xima fase. S√≥ avan√ßar ap√≥s checklist de navega√ß√£o, UI, dados e logs limpos.
**‚ö° IMPACTO:** Menos bugs em produ√ß√£o, evolu√ß√£o mais previs√≠vel e sustent√°vel.

### 34. CONSULTA CONT√çNUA √Ä DOCUMENTA√á√ÉO OFICIAL ANDROID
**‚ùå PROBLEMA:** D√∫vidas sobre padr√µes, permiss√µes, links, integra√ß√£o web, etc.
**‚úÖ SOLU√á√ÉO:** Sempre consultar a documenta√ß√£o oficial do Android Studio para decis√µes de arquitetura, navega√ß√£o, integra√ß√£o web, App Links, etc. Usar fontes externas confi√°veis apenas como complemento.
**‚ö° IMPACTO:** Evita decis√µes t√©cnicas erradas, garante ader√™ncia a padr√µes modernos e facilita manuten√ß√£o futura.
