# üì± GUIA T√âCNICO DE DESENVOLVIMENTO - GestaoBilhares

## üéØ **ARQUITETURA DO SISTEMA (Janeiro 2025)**

### **Estrutura de Projeto Atual**
```
app/src/main/java/com/example/gestaobilhares/
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ entities/           # Entidades do Room
‚îÇ   ‚îú‚îÄ‚îÄ dao/               # Data Access Objects
‚îÇ   ‚îú‚îÄ‚îÄ repository/        # Camada de Repository
‚îÇ   ‚îî‚îÄ‚îÄ database/          # Database configuration
‚îú‚îÄ‚îÄ ui/
‚îÇ   ‚îú‚îÄ‚îÄ settlement/        # Telas de Acerto
‚îÇ   ‚îú‚îÄ‚îÄ client/           # Telas de Cliente
‚îÇ   ‚îú‚îÄ‚îÄ route/            # Telas de Rota
‚îÇ   ‚îî‚îÄ‚îÄ shared/           # Componentes compartilhados
‚îî‚îÄ‚îÄ utils/
    ‚îú‚îÄ‚îÄ AppLogger.kt      # Sistema de logs
    ‚îî‚îÄ‚îÄ DateFormatter.kt  # Formata√ß√£o de datas
```

### **Padr√µes Arquiteturais Implementados**

#### **1. Sistema de Rotas com Ciclos Reais**
```kotlin
// RotaRepository - C√°lculo de ciclos reais
class RotaRepository(
    private val rotaDao: RotaDao,
    private val clienteDao: ClienteDao?,
    private val mesaDao: MesaDao?,
    private val acertoDao: AcertoDao?,
    private val cicloAcertoDao: CicloAcertoDao?
) {
    
    // ‚úÖ FUN√á√ÉO CR√çTICA: Calcula ciclo atual baseado nos acertos reais
    private fun calcularCicloAtualReal(rotaId: Long): Int {
        return try {
            // Primeiro, verificar se h√° ciclo em andamento
            val cicloAtivo = runBlocking {
                cicloAcertoDao?.buscarCicloEmAndamento(rotaId)
            }
            
            if (cicloAtivo != null) {
                // Se h√° ciclo em andamento, usar o n√∫mero dele
                cicloAtivo.numeroCiclo
            } else {
                // Se n√£o h√° ciclo em andamento, buscar o √∫ltimo ciclo finalizado
                val ultimoCiclo = runBlocking {
                    cicloAcertoDao?.buscarUltimoCicloPorRota(rotaId)
                }
                
                if (ultimoCiclo != null) {
                    // Se h√° ciclos finalizados, o pr√≥ximo ciclo seria o √∫ltimo + 1
                    ultimoCiclo.numeroCiclo + 1
                } else {
                    // Se n√£o h√° nenhum ciclo, come√ßar do 1
                    1
                }
            }
        } catch (e: Exception) {
            android.util.Log.e("RotaRepository", "Erro ao calcular ciclo atual: ${e.message}")
            1
        }
    }
    
    // ‚úÖ STATUS SIMPLIFICADO: Apenas 2 op√ß√µes
    private fun determinarStatusRota(rota: Rota): StatusRota {
        return try {
            val temCicloAtivo = runBlocking {
                val cicloAtivo = cicloAcertoDao?.buscarCicloEmAndamento(rota.id)
                cicloAtivo != null
            }
            
            if (temCicloAtivo) {
                StatusRota.EM_ANDAMENTO
            } else {
                StatusRota.FINALIZADA // Sempre finalizada se n√£o h√° ciclo ativo
            }
        } catch (e: Exception) {
            StatusRota.FINALIZADA
        }
    }
    
    // ‚úÖ FLOW COM DADOS REAIS
    fun getRotasResumoComAtualizacaoTempoReal(): Flow<List<RotaResumo>> {
        return getAllRotasAtivas().map { rotas ->
            rotas.map { rota ->
                val clientesAtivos = calcularClientesAtivosSync(rota.id)
                val pendencias = calcularPendenciasSync(rota.id)
                val valorAcertado = calcularValorAcertadoSync(rota.id)
                val quantidadeMesas = calcularQuantidadeMesasSync(rota.id)
                val percentualAcertados = calcularPercentualAcertadosSync(rota.id, clientesAtivos)
                
                // ‚úÖ USAR CICLO ATUAL REAL
                val status = determinarStatusRotaEmTempoReal(rota.id)
                val cicloAtual = calcularCicloAtualReal(rota.id)
                val dataCiclo = obterDataCicloAtual(rota.id)
                
                RotaResumo(
                    rota = rota,
                    clientesAtivos = clientesAtivos,
                    pendencias = pendencias,
                    valorAcertado = valorAcertado,
                    quantidadeMesas = quantidadeMesas,
                    percentualAcertados = percentualAcertados,
                    status = status,
                    cicloAtual = cicloAtual, // ‚úÖ CICLO REAL
                    dataCiclo = dataCiclo    // ‚úÖ DATA REAL
                )
            }
        }
    }
}
```

#### **2. MVVM Pattern**
```kotlin
// ViewModel - L√≥gica de Neg√≥cio
@HiltViewModel
class SettlementViewModel @Inject constructor(
    private val acertoRepository: AcertoRepository,
    private val cicloAcertoRepository: CicloAcertoRepository
) : ViewModel() {
    
    private val _resultadoSalvamento = MutableStateFlow<ResultadoSalvamento?>(null)
    val resultadoSalvamento: StateFlow<ResultadoSalvamento?> = _resultadoSalvamento.asStateFlow()
    
    sealed class ResultadoSalvamento {
        data class Sucesso(val acertoId: Long) : ResultadoSalvamento()
        data class AcertoJaExiste(val acerto: Acerto) : ResultadoSalvamento()
        data class Erro(val mensagem: String) : ResultadoSalvamento()
    }
}

// Fragment - UI e Intera√ß√£o
@AndroidEntryPoint
class SettlementFragment : Fragment() {
    
    @Inject
    lateinit var viewModel: SettlementViewModel
    
    private fun observarEstados() {
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.resultadoSalvamento.collect { resultado ->
                when (resultado) {
                    is ResultadoSalvamento.Sucesso -> handleSucesso(resultado.acertoId)
                    is ResultadoSalvamento.AcertoJaExiste -> handleAcertoExistente(resultado.acerto)
                    is ResultadoSalvamento.Erro -> handleErro(resultado.mensagem)
                }
            }
        }
    }
}
```

#### **2. Repository Pattern**
```kotlin
class AcertoRepository(
    private val acertoDao: AcertoDao,
    private val clienteDao: ClienteDao
) {
    // Opera√ß√µes CRUD b√°sicas
    suspend fun salvarAcerto(acerto: Acerto): Long = withContext(Dispatchers.IO) {
        acertoDao.inserir(acerto)
    }
    
    suspend fun buscarPorId(id: Long): Acerto? = withContext(Dispatchers.IO) {
        acertoDao.buscarPorId(id)
    }
    
    // Regras de neg√≥cio espec√≠ficas
    suspend fun verificarAcertoExistente(clienteId: Long, cicloId: Long): Acerto? {
        return withContext(Dispatchers.IO) {
            val acertos = acertoDao.buscarPorClienteECicloId(clienteId, cicloId).first()
            acertos.firstOrNull()
        }
    }
    
    // Valida√ß√µes de permiss√µes
    suspend fun podeEditarAcerto(acertoId: Long, cicloRepo: CicloAcertoRepository): PermissaoEdicao {
        return withContext(Dispatchers.IO) {
            val acerto = buscarPorId(acertoId) 
                ?: return@withContext PermissaoEdicao.NaoPodeEditar("Acerto n√£o encontrado")
            
            val cicloAtivo = cicloRepo.buscarCicloAtivoPorRota(acerto.rotaId)
                ?: return@withContext PermissaoEdicao.NaoPodeEditar("N√£o h√° ciclo ativo")
            
            val ultimoAcerto = buscarUltimoAcertoDoCiclo(acerto.rotaId, cicloAtivo.cicloAcerto)
            
            if (ultimoAcerto?.id == acertoId) {
                PermissaoEdicao.PodeEditar
            } else {
                PermissaoEdicao.NaoPodeEditar("Apenas o √∫ltimo acerto pode ser editado")
            }
        }
    }
}
```

#### **3. Sealed Classes para Type Safety**
```kotlin
sealed class PermissaoEdicao {
    object PodeEditar : PermissaoEdicao()
    data class NaoPodeEditar(val motivo: String) : PermissaoEdicao()
}

sealed class EstadoCarregamento<out T> {
    object Ocioso : EstadoCarregamento<Nothing>()
    object Carregando : EstadoCarregamento<Nothing>()
    data class Sucesso<T>(val dados: T) : EstadoCarregamento<T>()
    data class Erro(val exception: Throwable) : EstadoCarregamento<Nothing>()
}
```

---

## üõ†Ô∏è **FUNCIONALIDADES IMPLEMENTADAS**

### **1. Sistema de Acerto √önico por Ciclo**

#### **Regra de Neg√≥cio:**
- Cada cliente pode ter apenas 1 acerto por ciclo
- Valida√ß√£o no momento do salvamento
- Di√°logo informativo se acerto j√° existe

#### **Implementa√ß√£o:**
```kotlin
// No ViewModel
suspend fun salvarAcerto(/* par√¢metros */) {
    viewModelScope.launch {
        try {
            // Validar se j√° existe acerto
            val acertoExistente = acertoRepository.verificarAcertoExistente(clienteId, cicloId)
            if (acertoExistente != null) {
                _resultadoSalvamento.value = ResultadoSalvamento.AcertoJaExiste(acertoExistente)
                return@launch
            }
            
            // Salvar novo acerto
            val acertoId = acertoRepository.salvarAcerto(novoAcerto)
            _resultadoSalvamento.value = ResultadoSalvamento.Sucesso(acertoId)
            
        } catch (e: Exception) {
            _resultadoSalvamento.value = ResultadoSalvamento.Erro(e.message ?: "Erro desconhecido")
        }
    }
}

// No Fragment
private fun mostrarDialogoAcertoJaExiste(acerto: Acerto) {
    AlertDialog.Builder(requireContext())
        .setTitle("‚ö†Ô∏è Acerto J√° Realizado")
        .setMessage(
            "Este cliente j√° possui um acerto salvo neste ciclo.\n\n" +
            "üìã Detalhes:\n" +
            "‚Ä¢ ID: #${acerto.id.formatarId()}\n" +
            "‚Ä¢ Valor: ${acerto.valorRecebido.formatarMoeda()}\n\n" +
            "üí° Para alterar, acesse o hist√≥rico."
        )
        .setPositiveButton("Ver Hist√≥rico") { _, _ ->
            findNavController().popBackStack()
        }
        .setNegativeButton("OK", null)
        .show()
}
```

### **2. Sistema de Edi√ß√£o de Acerto**

#### **Regras de Neg√≥cio:**
- Apenas o √∫ltimo acerto do ciclo ativo pode ser editado
- Valida√ß√£o baseada no estado do ciclo
- Navega√ß√£o segura com SafeArgs

#### **Implementa√ß√£o:**
```kotlin
// Navega√ß√£o SafeArgs
val action = SettlementDetailFragmentDirections
    .actionSettlementDetailFragmentToSettlementFragment(
        clienteId = acerto.clienteId,
        acertoIdParaEdicao = acerto.id
    )
findNavController().navigate(action)

// Valida√ß√£o de permiss√£o
private fun verificarPermissaoEdicao() {
    lifecycleScope.launch {
        when (val permissao = acertoRepo.podeEditarAcerto(args.acertoId, cicloRepo)) {
            is PermissaoEdicao.PodeEditar -> {
                navegarParaEdicao()
            }
            is PermissaoEdicao.NaoPodeEditar -> {
                mostrarDialogoPermissaoNegada(permissao.motivo)
            }
        }
    }
}
```

### **3. Corre√ß√£o RecyclerView + NestedScrollView**

#### **Problema Identificado:**
RecyclerView dentro de ScrollView n√£o exibia todos os itens (apenas o primeiro)

#### **Solu√ß√£o Oficial Android:**
```xml
<!-- ‚ùå Problema: ScrollView tradicional -->
<ScrollView>
    <RecyclerView 
        android:nestedScrollingEnabled="true" />
</ScrollView>

<!-- ‚úÖ Solu√ß√£o: NestedScrollView -->
<androidx.core.widget.NestedScrollView>
    <RecyclerView 
        android:nestedScrollingEnabled="false" />
</androidx.core.widget.NestedScrollView>
```

#### **Configura√ß√£o Kotlin:**
```kotlin
binding.rvMesasDetalhe.apply {
    layoutManager = LinearLayoutManager(requireContext())
    adapter = mesaDetailAdapter
    // Configura√ß√£o oficial para NestedScrollView
    isNestedScrollingEnabled = false
    setHasFixedSize(false)
}
```

---

## üîç **DEBUGGING E MONITORAMENTO**

### **1. Sistema de Logs Estruturado**
```kotlin
// AppLogger centralizado
object AppLogger {
    fun log(tag: String, message: String) {
        Log.d(tag, message)
    }
    
    fun error(tag: String, message: String, throwable: Throwable? = null) {
        Log.e(tag, message, throwable)
    }
}

// Uso nos componentes
AppLogger.log("SettlementFragment", "=== CONFIGURANDO RECYCLERVIEW ===")
AppLogger.log("AcertoRepository", "Verificando acerto existente: clienteId=$clienteId, cicloId=$cicloId")
AppLogger.error("SettlementViewModel", "Erro ao salvar acerto", exception)
```

### **2. Monitoramento de Crashes em Tempo Real**
```powershell
# Script crash.ps1 para Windows
C:\Users\Rossiny\AppData\Local\Android\Sdk\platform-tools\adb.exe logcat | findstr /i "gestaobilhares\|FATAL\|AndroidRuntime\|crash\|Exception\|Caused by"
```

### **3. Valida√ß√£o de Build**
```bash
# Sequ√™ncia obrigat√≥ria para problemas de build
./gradlew clean
./gradlew compileDebugKotlin --stacktrace
./gradlew assembleDebug
```

---

## üé® **PADR√ïES DE UI/UX**

### **1. Di√°logos Material Design**
```kotlin
private fun criarDialogoInformativo(titulo: String, mensagem: String) {
    MaterialAlertDialogBuilder(requireContext())
        .setTitle(titulo)
        .setMessage(mensagem)
        .setPositiveButton("OK", null)
        .show()
}

private fun criarDialogoConfirmacao(
    titulo: String, 
    mensagem: String, 
    onConfirm: () -> Unit
) {
    MaterialAlertDialogBuilder(requireContext())
        .setTitle(titulo)
        .setMessage(mensagem)
        .setPositiveButton("Confirmar") { _, _ -> onConfirm() }
        .setNegativeButton("Cancelar", null)
        .show()
}
```

### **2. Estados de Loading**
```kotlin
// ViewModel
private val _isLoading = MutableStateFlow(false)
val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()

fun setLoading(loading: Boolean) {
    _isLoading.value = loading
}

// Fragment
private fun observarEstadoLoading() {
    viewLifecycleOwner.lifecycleScope.launch {
        viewModel.isLoading.collect { isLoading ->
            binding.progressBar.isVisible = isLoading
            binding.btnSave.isEnabled = !isLoading
        }
    }
}
```

### **3. Formata√ß√£o Consistente**
```kotlin
// Extension functions para formata√ß√£o
fun Double.formatarMoeda(): String = "R$ ${String.format("%.2f", this)}"
fun Long.formatarId(): String = "#${this.toString().padStart(4, '0')}"
fun Date.formatarData(): String = SimpleDateFormat("dd/MM/yyyy", Locale.getDefault()).format(this)

// Uso
textViewValor.text = acerto.valorRecebido.formatarMoeda()
textViewId.text = acerto.id.formatarId()
textViewData.text = acerto.dataAcerto.formatarData()
```

---

## üìä **VALIDA√á√ÉO E TESTES**

### **1. Unit Tests para Repository**
```kotlin
@Test
fun `verificarAcertoExistente deve retornar acerto quando existe`() = runTest {
    // Given
    val clienteId = 1L
    val cicloId = 1L
    val acertoExistente = Acerto(id = 1, clienteId = clienteId, /* ... */)
    
    // When
    coEvery { acertoDao.buscarPorClienteECicloId(clienteId, cicloId) } returns flowOf(listOf(acertoExistente))
    
    // Then
    val resultado = repository.verificarAcertoExistente(clienteId, cicloId)
    assertEquals(acertoExistente, resultado)
}
```

### **2. Testes de Integra√ß√£o**
```kotlin
@Test
fun `salvar acerto deve falhar quando cliente ja possui acerto no ciclo`() = runTest {
    // Given
    val clienteId = 1L
    val cicloId = 1L
    val acertoExistente = criarAcertoMock(clienteId = clienteId)
    
    coEvery { repository.verificarAcertoExistente(clienteId, cicloId) } returns acertoExistente
    
    // When
    viewModel.salvarAcerto(/* par√¢metros */)
    
    // Then
    val resultado = viewModel.resultadoSalvamento.value
    assertIs<ResultadoSalvamento.AcertoJaExiste>(resultado)
    assertEquals(acertoExistente, resultado.acerto)
}
```

### **3. Testes de UI**
```kotlin
@Test
fun `deve mostrar dialogo quando acerto ja existe`() {
    // Given
    val acerto = criarAcertoMock()
    
    // When
    launchFragmentInContainer<SettlementFragment>()
    // Simular resultado AcertoJaExiste
    
    // Then
    onView(withText("‚ö†Ô∏è Acerto J√° Realizado")).check(matches(isDisplayed()))
    onView(withText("Ver Hist√≥rico")).check(matches(isDisplayed()))
}
```

---

## üöÄ **DEPLOYMENT E BUILD**

### **1. Configura√ß√£o de Build**
```gradle
android {
    compileSdk 34
    
    defaultConfig {
        minSdk 24
        targetSdk 34
        versionCode 1
        versionName "1.0"
    }
    
    buildTypes {
        debug {
            debuggable true
            applicationIdSuffix ".debug"
        }
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    
    kotlinOptions {
        jvmTarget = '1.8'
    }
    
    buildFeatures {
        viewBinding true
    }
}
```

### **2. Depend√™ncias Principais**
```gradle
dependencies {
    // Core Android
    implementation 'androidx.core:core-ktx:1.12.0'
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'com.google.android.material:material:1.11.0'
    
    // Navigation
    implementation 'androidx.navigation:navigation-fragment-ktx:2.7.6'
    implementation 'androidx.navigation:navigation-ui-ktx:2.7.6'
    
    // Room Database
    implementation 'androidx.room:room-runtime:2.6.1'
    implementation 'androidx.room:room-ktx:2.6.1'
    kapt 'androidx.room:room-compiler:2.6.1'
    
    // Lifecycle
    implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.7.0'
    implementation 'androidx.lifecycle:lifecycle-livedata-ktx:2.7.0'
    
    // Hilt Dependency Injection
    implementation 'com.google.dagger:hilt-android:2.48'
    kapt 'com.google.dagger:hilt-android-compiler:2.48'
    
    // Testing
    testImplementation 'junit:junit:4.13.2'
    testImplementation 'org.mockito.kotlin:mockito-kotlin:5.2.1'
    testImplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3'
    androidTestImplementation 'androidx.test.ext:junit:1.1.5'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
}
```

### **3. Processo de Release**
```bash
# 1. Limpar projeto
./gradlew clean

# 2. Executar testes
./gradlew test

# 3. Gerar APK debug
./gradlew assembleDebug

# 4. Gerar APK release (quando pronto)
./gradlew assembleRelease
```

---

## üìã **CHECKLIST PR√â-COMMIT**

### **Antes de cada commit, verificar:**

- [ ] **Build limpo**: `./gradlew compileDebugKotlin` sem erros
- [ ] **Testes passando**: Funcionalidade testada end-to-end
- [ ] **Logs estruturados**: AppLogger implementado onde necess√°rio
- [ ] **Valida√ß√µes funcionando**: Regras de neg√≥cio testadas
- [ ] **UI responsiva**: Interface testada em diferentes tamanhos
- [ ] **Navega√ß√£o segura**: SafeArgs usado corretamente
- [ ] **Mensagens claras**: Di√°logos informativos implementados
- [ ] **Documenta√ß√£o atualizada**: Status e guias atualizados

### **Padr√£o de Commit:**
```
üîß [TIPO]: Descri√ß√£o breve

‚úÖ IMPLEMENTADO:
‚Ä¢ Funcionalidade 1
‚Ä¢ Funcionalidade 2

üìã DETALHES T√âCNICOS:
‚Ä¢ Mudan√ßa t√©cnica 1
‚Ä¢ Mudan√ßa t√©cnica 2

üéØ RESULTADO:
‚Ä¢ Benef√≠cio para usu√°rio final
```

---

**CRIADO:** 07/01/2025  
**AUTOR:** Desenvolvedor Android S√™nior  
**VERS√ÉO:** 1.0  
**STATUS:** Funcionalidades de edi√ß√£o implementadas e documentadas
description:
globs:
alwaysApply: false
---
