# ğŸš€ WINDSURF RULES - GESTÃƒO DE BILHARES

> Regras e configuraÃ§Ãµes otimizadas para WindSurf baseadas na documentaÃ§Ã£o do projeto  
> VersÃ£o: 1.0  
> Baseado em: PROJECT_README.md, DEV_GUIDE.md, TECHNICAL_DEBT.md  
> Stack: Kotlin + Android + MVVM + Hilt + Room + Firebase

---

## ğŸ¯ OBJETIVO

Configurar WindSurf para desenvolvimento com **ALTA AUTONOMIA** seguindo o protocolo Gates (mÃ¡ximo 2 builds por problema) e diagnÃ³stico baseado em evidÃªncia.

---

## ğŸ”§ REGRAS DE CODIFICAÃ‡ÃƒO

### 1. Arquitetura ObrigatÃ³ria
- **MVVM** com ViewModels, Repositories e DAOs
- **Hilt** para injeÃ§Ã£o de dependÃªncias (@Inject, @HiltViewModel)
- **StateFlow** (nÃ£o LiveData) para streams reativos
- **Coroutines** para operaÃ§Ãµes assÃ­ncronas

### 2. Multi-tenancy por Rota
```kotlin
// OBRIGATÃ“RIO em todas as entidades
data class Cliente(
    val empresa_id: String,
    val rota_id: String,
    // ... outros campos
)

// ValidaÃ§Ã£o de acesso
if (!userSessionManager.canAccessRota(rota_id)) {
    throw SecurityException("Acesso negado")
}
```

### 3. Offline-First
```kotlin
// Room Ã© a fonte da verdade
suspend fun getClientes(): Flow<List<Cliente>> = flow {
    // 1. Emitir local imediatamente
    emitAll(dao.getAllClientes())
    
    // 2. Sync em background se online
    if (networkUtils.isConnected()) {
        syncFromFirestore()
    }
}
```

### 4. PadrÃ£o de Logs
```kotlin
private const val TAG = "[DIAGNOSTICO]"

Log.d(TAG, "INICIANDO salvarAcerto")
Log.d(TAG, "ANTES: usuarioId=$usuarioId")
Log.d(TAG, "DEPOIS: acertoId=$acertoId")
```

---

## ğŸšª GATES DE DIAGNÃ“STICO (Protocolo ObrigatÃ³rio)

### Gate 0 - DiagnÃ³stico Primeiro
```
PROBLEMA IDENTIFICADO
â”œâ”€ RegressÃ£o / "funcionava antes"? â†’ Static Analysis (mÃ¡x 1 build)
â”œâ”€ Erro visÃ­vel no cÃ³digo?         â†’ Static Analysis (mÃ¡x 1 build)
â””â”€ CÃ³digo parece OK mas falha?    â†’ Dynamic Analysis (logs) (mÃ¡x 2 builds)
```

### Gate 1 - Plano CirÃºrgico
- [ ] Arquivo-alvo identificado
- [ ] Linhas especÃ­ficas
- [ ] MudanÃ§a exata definida
- [ ] ValidaÃ§Ã£o mÃ­nima estabelecida

### Gate 2 - Escopo Delimitado
- [ ] Arquivos que serÃ£o modificados
- [ ] Arquivos que NÃƒO serÃ£o tocados
- [ ] DependÃªncias impactadas

### Gate 3 - ExecuÃ§Ã£o Incremental
- [ ] Uma mudanÃ§a por vez
- [ ] ValidaÃ§Ã£o imediata
- [ ] Rollback se piorar

### Gate 4 - Parada ObrigatÃ³ria
- [ ] MÃ¡ximo 2 builds sem sucesso
- [ ] 3 tentativas sem soluÃ§Ã£o
- [ ] Pedir ajuda humana

---

## ğŸ”¨ COMANDOS ESSENCIAIS (WindSurf)

### Build (SEMPRE .bat)
```bash
# Build debug
.\gradlew.bat :app:assembleDebug

# Com cache e paralelismo
.\gradlew.bat :app:assembleDebug --build-cache --parallel

# Testes
.\gradlew.bat testDebugUnitTest
```

### ADB Customizado
```bash
# Path obrigatÃ³rio
set ADB_PATH=C:\Users\Rossiny\Desktop\2-GestaoBilhares\android-sdk\platform-tools\adb.exe

# Logs por tag
%ADB_PATH% logcat -s [DIAGNOSTICO]:D -v time

# MÃºltiplas tags
%ADB_PATH% logcat -s [DIAGNOSTICO]:D [SYNC]:D [CONFLICT]:D *:E
```

### Busca no CÃ³digo
```bash
# Encontrar componentes
rg "SettlementViewModel" --type kt -n
rg "sync_operations" --type kt -C 5

# Arqueologia (regressÃ£o)
rg "usuarioId" --type kt -C 3
rg "groupBy" --type kt
```

---

## ğŸ“ ESTRUTURA DE ARQUIVOS

### PadrÃ£o de Nomes
```
data/src/main/java/.../data/
â”œâ”€â”€ dao/
â”‚   â”œâ”€â”€ ClienteDao.kt
â”‚   â”œâ”€â”€ AcertoDao.kt
â”‚   â””â”€â”€ SyncOperationDao.kt
â”œâ”€â”€ repository/
â”‚   â”œâ”€â”€ ClienteRepository.kt (interface)
â”‚   â”œâ”€â”€ ClienteRepositoryImpl.kt
â”‚   â””â”€â”€ AppRepository.kt (FACADE - NÃƒO REFACTORAR)
â””â”€â”€ usecases/
    â””â”€â”€ RegistrarTrocaPanoUseCase.kt

ui/src/main/java/.../ui/
â”œâ”€â”€ settlement/
â”‚   â”œâ”€â”€ SettlementFragment.kt
â”‚   â””â”€â”€ SettlementViewModel.kt
â””â”€â”€ cliente/
    â”œâ”€â”€ ClienteFragment.kt
    â””â”€â”€ ClienteViewModel.kt
```

### Firestore Path (OBRIGATÃ“RIO)
```
empresas/{empresaId}/entidades/{collection}/items/{itemId}
```

---

## ğŸš¨ REGRAS ANTI-LOOP

### Proibido
- âŒ Mais de 2 builds por problema
- âŒ Pular Gate 0 (diagnÃ³stico)
- âŒ Usar LiveData (sÃ³ StateFlow)
- âŒ Acessar DAO/Firebase diretamente da UI
- âŒ Esquecer `rota_id` em entidades
- âŒ Usar path ADB padrÃ£o (usar customizado)

### ObrigatÃ³rio
- âœ… Static Analysis primeiro
- âœ… Logs com [TAG] estruturada
- âœ… Comandos `.bat` sempre
- âœ… Multi-tenancy por rota
- âœ… Room como fonte da verdade
- âœ… MVVM + Hilt + StateFlow

---

## ğŸ” RECEITAS DE DIAGNÃ“STICO

### Campo estÃ¡ Null
```kotlin
// 1. Encontrar criaÃ§Ã£o
rg "HistoricoManutencao" --type kt -C 3

// 2. Ver construtor
data class HistoricoManutencao(
    val mesaId: Long,
    val usuarioId: Long?  // â† Nullable?
)

// 3. Ver instanciaÃ§Ã£o
HistoricoManutencao(
    mesaId = 1
    // FALTA usuarioId!
)
```

### Dados nÃ£o aparecem
```kotlin
// CAMADA 1: DAO - Query correta?
@Query("SELECT * FROM historico WHERE acertoId = :id")

// CAMADA 2: ViewModel - Transforma certo?
val items = repository.getHistorico(id)
    .groupBy { it.mesaId }  // â† Agrupando?

// CAMADA 3: UI - Observa certo?
items.collectAsState()  // StateFlow correto?
```

### PERMISSION_DENIED
```bash
# 1. Ver path no cÃ³digo
Log.d("PATH", "Acessando: ${docRef.path}")

# 2. Verificar campos obrigatÃ³rios
data.empresa_id == empresaId  // âœ“
data.rota_id in rotasPermitidas  // âœ“

# 3. Verificar token
%ADB_PATH% logcat -s FirebaseAuth:D | grep "claims"
```

---

## ğŸ“Š MÃ‰TRICAS E MONITORAMENTO

### Build Performance
- **Meta:** < 5 minutos com cache
- **Comando:** `.\gradlew.bat :app:assembleDebug --build-cache --parallel`

### Test Coverage
- **Atual:** 5-7%
- **Meta 2 semanas:** 30%
- **Meta 1 mÃªs:** 60%

### Sync Performance
- **Meta:** < 2 segundos
- **Monitoramento:** Logs [SYNC] com timestamps

---

## ğŸ¯ WORKFLOWS DE DESENVOLVIMENTO

### Workflow 1: Bug Fix
1. **Gate 0:** Static Analysis do cÃ³digo
2. **Gate 1:** Identificar arquivo/linha do problema
3. **Gate 2:** Definir mudanÃ§a exata
4. **Gate 3:** Implementar mudanÃ§a
5. **Validar:** Build + Testes
6. **Gate 4:** Parar se falhar apÃ³s 2 builds

### Workflow 2: Nova Feature
1. **Ler:** PROJECT_README.md (seÃ§Ã£o componente)
2. **Seguir:** PadrÃ£o MVVM + Hilt
3. **Implementar:** DAO â†’ Repository â†’ ViewModel â†’ UI
4. **Testar:** UnitÃ¡rios primeiro
5. **Integrar:** Sync com Firestore
6. **Validar:** Multi-tenancy + Offline-first

### Workflow 3: RefatoraÃ§Ã£o
1. **Identificar:** DÃ©bito em TECHNICAL_DEBT.md
2. **Planejar:** MudanÃ§as incrementais
3. **Executar:** Uma classe por vez
4. **Testar:** Sem regressÃµes
5. **Documentar:** Atualizar docs

---

## ğŸš€ AUTOMAÃ‡ÃƒO WINDSURF

### Snippets Ãšteis
```kotlin
// ViewModel pattern
@HiltViewModel
class ${ViewModelName} @Inject constructor(
    private val repository: ${RepositoryName}
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(${UiStateName}.InitialState)
    val uiState: StateFlow<${UiStateName}> = _uiState.asStateFlow()
}

// DAO pattern
@Dao
interface ${EntityName}Dao {
    @Query("SELECT * FROM ${tableName}")
    fun getAll(): Flow<List<${EntityName}>>
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(entity: ${EntityName}): Long
}
```

### ValidaÃ§Ãµes AutomÃ¡ticas
- [ ] Multi-tenancy respeitado?
- [ ] Offline-first mantido?
- [ ] StateFlow usado?
- [ ] Logs estruturados?
- [ ] Build passa?

---

## ğŸ“‹ CHECKLIST FINAL

Antes de considerar tarefa concluÃ­da:

- [ ] **Build passa:** `.\gradlew.bat :app:assembleDebug`
- [ ] **Testes passam:** `.\gradlew.bat testDebugUnitTest`
- [ ] **Arquitetura MVVM:** ViewModels â†’ Repositories â†’ DAOs
- [ ] **Multi-tenancy:** `rota_id` presente e validado
- [ ] **Offline-first:** Room primeiro, sync depois
- [ ] **Logs estruturados:** [TAG] padrÃ£o seguido
- [ ] **MÃ¡ximo 2 builds:** Protocolo Gates respeitado
- [ ] **Zero regressÃµes:** Funcionalidades intactas

---

## ğŸ”— REFERÃŠNCIAS

- **PROJECT_README.md:** Arquitetura e componentes
- **DEV_GUIDE.md:** Protocolo Gates e diagnÃ³stico
- **TECHNICAL_DEBT.md:** DÃ©bitos priorizados
- **Stack:** Kotlin 1.9.20 + Android SDK 34 + Hilt + Room + Firebase

---

*ConfiguraÃ§Ã£o otimizada para desenvolvimento autÃ´nomo e eficiente.*
